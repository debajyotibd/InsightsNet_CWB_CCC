.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "CWB::CQP 3pm"
.TH CWB::CQP 3pm "2023-06-22" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CWB::CQP \- Interact with a CQP process running in the background
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use CWB::CQP;
\&
\&  # start CQP server process in the background
\&  $cqp = new CWB::CQP;
\&  $cqp = new CWB::CQP("\-r /corpora/registry", "\-I /global/init.cqp");
\&
\&  # check for specified or newer CQP version
\&  $ok = $cqp\->check_version($major, $minor, $beta);
\&
\&  # activate corpus in managed mode (automatic character encoding conversion)
\&  $cqp\->activate($corpus);
\&
\&  # execute CQP command (blocking mode) and check for error
\&  @lines = $cqp\->exec($my_cmd);
\&  unless ($cqp\->ok) {
\&    @cqp_error_message = $cqp\->error_message;
\&    my_error_handler();
\&  }
\&
\&  # it\*(Aqs easier to use an automatic error handler
\&  $cqp\->set_error_handler(\e&my_error_handler); # user\-defined
\&  $cqp\->set_error_handler(\*(Aqdie\*(Aq); # built\-in, useful for one\-off scripts
\&
\&  # read TAB\-delimited table from count, group, tabulate, ...
\&  @table = $cqp\->exec_rows($my_cmd);
\&
\&  # run CQP command in background (non\-blocking mode)
\&  $cqp\->run($my_cmd);
\&  if ($cqp\->ready) {  # specify optional timeout in seconds
\&    my $line = $cqp\->getline;
\&    my @fields = $cqp\->getrow; # TAB\-delimited output
\&  }
\&  @lines = $cqp\->getlines(10); # reads 10 lines, blocking if necessary
\&
\&  # execute in query lock mode (to improve security of CGI scripts)
\&  $cqp\->begin_query;
\&    # execute untrusted CQP queries
\&  $cqp\->end_query;
\&  
\&  @lines = $cqp\->exec_query($untrusted_query); # convenience wrapper
\&  
\&  # dump/undump a named query into/from a table of corpus positions
\&  @matches = $cqp\->dump("Last" [, $from, $to]);
\&  $cqp\->undump("Copy", @matches);  # produces copy of "Last"
\&
\&  # safely quote regular expressions and literal strings for CQP queries
\&  $query = $cqp\->quote(\*(Aq[0\-9]+"\-[a\-z\-]+\*(Aq);      # picks single or double quotes
\&  $query = $cqp\->quote($cqp\->quotemeta($word)); # escape all metacharacters
\&
\&  # activate CQP progress messages during query execution
\&  $cqp\->progress_on;
\&  $status = $cqp\->progress; # after starting CQP command with run()
\&  ($total, $pass, $n_passes, $msg, $percent) = $cqp\->progress_info;
\&  $cqp\->progress_off;
\&
\&  $cqp\->set_progress_handler(\e&my_progress_handler); # user\-defined handler
\&
\&  # shut down CQP server (exits gracefully)
\&  undef $cqp;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \fB\s-1CWB::CQP\s0\fR object represents an instance of the corpus query processor \s-1CQP\s0
running as a background process.  By calling suitable methods on this object,
arbitrary \s-1CQP\s0 commands can be executed and their output can be captured.
The \f(CW\*(C`STDERR\*(C'\fR stream of the \s-1CQP\s0 process is monitored for error messages,
which can automatically trigger an error handler.
.PP
Every \fB\s-1CWB::CQP\s0\fR object has its own \s-1CQP\s0 background process and communication is
fully asynchronous.  This enables scripts to perform other actions while a long
\&\s-1CQP\s0 command is executing, or to run multiple \s-1CQP\s0 instances in parallel.
.PP
In managed mode (enabled with the \fBactivate\fR method), the \s-1API\s0 works consistently
with Perl Unicode strings, which are automatically translated to the character
encoding of the \s-1CWB\s0 corpus in the background.
.SH "METHODS"
.IX Header "METHODS"
The following methods are available:
.IP "\fI\f(CI$cqp\fI\fR = \fBnew\fR \s-1CWB::CQP\s0;" 4
.IX Item "$cqp = new CWB::CQP;"
.PD 0
.IP "\fI\f(CI$cqp\fI\fR = \fBnew\fR \s-1CWB::CQP\s0 '\-r /corpora/registry', '\-l /data/cqpresults';" 4
.IX Item "$cqp = new CWB::CQP '-r /corpora/registry', '-l /data/cqpresults';"
.PD
Spawn new \s-1CQP\s0 background process.  The object \fI\f(CI$cqp\fI\fR can then be used to communicate with 
this \s-1CQP\s0 instance.  Optional arguments of the \fBnew\fR method are passed as command-line
options to \s-1CQP.\s0  Use at your own risk.
.IP "\fBundef\fR \fI\f(CI$cqp\fI\fR;" 4
.IX Item "undef $cqp;"
Exit \s-1CQP\s0 background process gracefully by issuing an \f(CW\*(C`exit;\*(C'\fR command.
This is done automatically when the variable \fI\f(CI$cqp\fI\fR goes out of scope.
Note that there may be a slight delay while \fB\s-1CWB::CQP\s0\fR waits for the \s-1CQP\s0
process to terminate.
.Sp
\&\fBDo \s-1NOT\s0\fR send an \f(CW\*(C`exit;\*(C'\fR command to \s-1CQP\s0 explicitly (with \fBexec\fR or \fBrun\fR).
This looks like a program crash to \fB\s-1CWB::CQP\s0\fR and will result in immediate
termination of the Perl script.
.IP "\fI\f(CI$ok\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBcheck_version\fR(\fI\f(CI$major\fI\fR, \fI\f(CI$minor\fI\fR, \fI\f(CI$beta\fI\fR);" 4
.IX Item "$ok = $cqp->check_version($major, $minor, $beta);"
Check for minimum required \s-1CQP\s0 version, i.e. the background process has
to be \s-1CQP\s0 version \fI\f(CI$major\fI\fR.\fI\f(CI$minor\fI\fR.\fI\f(CI$beta\fI\fR or newer.
\&\fI\f(CI$minor\fI\fR and \fI\f(CI$beta\fI\fR may be omitted, in which case they default to 0.
Note that the \fB\s-1CWB::CQP\s0\fR module automatically checks whether the \s-1CQP\s0 version
is compatible with its own requirements when a new object is created.
The \fBcheck_version\fR method can subsequently be used to check for a more
recent release that provides functionality needed by the Perl script.
.IP "\fI\f(CI$version_string\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBversion\fR;" 4
.IX Item "$version_string = $cqp->version;"
Returns formatted version string for the \s-1CQP\s0 background process, e.g. \f(CW2.2.99\fR or \f(CW3.5.0\fR.
.IP "\fI\f(CI$cqp\fI\fR\->\fBactivate\fR(\fI\f(CI$corpus\fI\fR);" 4
.IX Item "$cqp->activate($corpus);"
Activate \fI\f(CI$corpus\fI\fR and enable \fBmanaged mode\fR, i.e. automatic conversion between Perl
Unicode strings and the character encoding of the \s-1CWB\s0 corpus.  Conversion works in
both directions, so \s-1CQP\s0 commands and queries must be passed as Perl Unicode strings and
all return values are guaranteed to be Perl Unicode strings.
.Sp
Managed mode simplifies interaction with \s-1CWB\s0 corpora in different encodings and ensures
that Perl string operations are carried out correctly with Unicode character semantics
(string length, case conversion for non-ASCII letters, Unicode character classes in
regular expressions, etc.).
.Sp
Possible reasons for using non-managed (raw) mode are: (i) that Latin1\-encoded corpora
can be processed faster as raw byte sequences; and (ii) that arbitrary byte values can
be handled, even if they are not valid Latin1 code points.
.Sp
\&\fB\s-1NB:\s0\fR Once managed mode has been enabled, make sure always to use \fBactivate\fR to switch
to a different corpus.  If the corpus is activated with a plain \fBexec\fR commmand, the
\&\fI\f(CI$cqp\fI\fR object will not be notified of changes in character encoding.
.Sp
Pass \fBundef\fR to disable managed mode and change back to raw byte semantics.
.IP "\fI\f(CI$cqp\fI\fR\->\fBrun\fR(\fI\f(CI$cmd\fI\fR);" 4
.IX Item "$cqp->run($cmd);"
Start a single \s-1CQP\s0 command \fI\f(CI$cmd\fI\fR in the background.  This method returns immediately.
Command output can then be read with the \fBgetline\fR, \fBgetlines\fR and \fBgetrow\fR methods.
If asynchronous communication is desired, use \fBready\fR to check whether output is available.
.Sp
It is an error to \fBrun\fR a new command before the output of the previous command has completely
been processed.
.IP "\fI\f(CI$num_of_lines\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBready\fR;" 4
.IX Item "$num_of_lines = $cqp->ready;"
.PD 0
.IP "\fI\f(CI$num_of_lines\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBready\fR(\fI\f(CI$timeout\fI\fR);" 4
.IX Item "$num_of_lines = $cqp->ready($timeout);"
.PD
Check if output from current \s-1CQP\s0 command is available for reading with \fBgetline\fR etc.,
returning the number of lines currently held in the input buffer (possibly including an
end-of-output marker line that will not be returned by \fBgetline\fR etc.).  If there is no
active command, returns \fBundef\fR.
.Sp
The first form of the command returns immediately.  The second form waits up to \fI\f(CI$timeout\fI\fR
seconds for \s-1CQP\s0 output to become available.  Use a negative \fI\f(CI$timeout\fI\fR for blocking mode.
.IP "\fI\f(CI$line\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBgetline\fR;" 4
.IX Item "$line = $cqp->getline;"
Read one line of output from \s-1CQP\s0 process, blocking if necessary until output beomes available.
Returns \fBundef\fR when all output from the current \s-1CQP\s0 command has been read.
.IP "\fI\f(CI@lines\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBgetlines\fR(\fI\f(CI$n\fI\fR);" 4
.IX Item "@lines = $cqp->getlines($n);"
Read \fI\f(CI$n\fI\fR lines of output from the \s-1CQP\s0 process, blocking as long as necessary.  An explicit \fBundef\fR element is included at the end of the output of a \s-1CQP\s0 command.  Note that \fBgetlines\fR may return fewer than \fI\f(CI$n\fI\fR lines if the end of output is reached.
.Sp
Set \f(CW\*(C`\f(CI$n\f(CW = 0\*(C'\fR to read all complete lines currently held in the input buffer (as indicated by the \fBready\fR method), or specify a negative value to read the complete output of the active \s-1CQP\s0 command.
.IP "\fI\f(CI@lines\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBexec\fR(\fI\f(CI$cmd\fI\fR);" 4
.IX Item "@lines = $cqp->exec($cmd);"
A convenience function that executes \s-1CQP\s0 command \fI\f(CI$cmd\fI\fR, waits for it to complete, and returns all lines of
output from the command.
.Sp
Fully equivalent to the following two commands, except that the trailing \fBundef\fR returnd by \fBgetlines\fR is not included in the output:
.Sp
.Vb 2
\&  $cqp\->run($cmd);
\&  @lines = $cqp\->getlines(\-1);
.Ve
.IP "\fI\f(CI@fields\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBgetrow\fR;" 4
.IX Item "@fields = $cqp->getrow;"
.PD 0
.IP "\fI\f(CI@rows\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBexec_rows\fR(\fI\f(CI$cmd\fI\fR);" 4
.IX Item "@rows = $cqp->exec_rows($cmd);"
.PD
Convenience functions for reading TAB-delimited tables, which are generated by \s-1CQP\s0 commands such as \fBcount\fR, \fBgroup\fR, \fBtabulate\fR and \fBshow cd\fR.
.Sp
\&\fBgetrow\fR returns a single row of output, split into TAB-delimited fields.  If the active \s-1CQP\s0 command has completed, it returns an empty list.
.Sp
\&\fBexec_rows\fR executes the \s-1CQP\s0 command \fI\f(CI$cmd\fI\fR, waits for it to complete, and then returns the TAB-delimited table as an array of array references.  You can then use multiple indices to access a specific element of the table, e.g. \f(CW\*(C`\f(CI@rows\f(CW[41][2]\*(C'\fR for the third column of the 42nd row.
.IP "\fI\f(CI$cqp\fI\fR\->\fBbegin_query\fR;" 4
.IX Item "$cqp->begin_query;"
.PD 0
.IP "\fI\f(CI$cqp\fI\fR\->\fBend_query\fR;" 4
.IX Item "$cqp->end_query;"
.PD
Enter/exit query lock mode for safe execution of \s-1CQP\s0 queries entered by an untrusted user (e.g. from a Web interface).  In query lock mode, all interactive \s-1CQP\s0 commands are temporarily disabled; in particular, it is impossible to access files or execute shell commands from \s-1CQP.\s0
.IP "\fI\f(CI@lines\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBexec_query\fR(\fI\f(CI$query\fI\fR);" 4
.IX Item "@lines = $cqp->exec_query($query);"
Convenience function to execute a \s-1CQP\s0 query \fI\f(CI$query\fI\fR in safe query lock mode, wait for it to complete, and return its output as a list of lines.
.Sp
Fully equivalent to the following sequence:
.Sp
.Vb 3
\&  $cqp\->begin_query;
\&  @lines = $cqp\->exec($query);
\&  $cqp\->end_query;
.Ve
.IP "\fI\f(CI@table\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBdump\fR(\fI\f(CI$named_query\fI\fR [, \fI\f(CI$from\fI\fR, \fI\f(CI$to\fI\fR]);" 4
.IX Item "@table = $cqp->dump($named_query [, $from, $to]);"
Dump a named query result \fI\f(CI$named_query\fI\fR (or a part of it ranging from line \fI\f(CI$from\fI\fR to line \fI\f(CI$to\fI\fR) into a table of corpus positions, where each row corresponds to one match of the query.  The table always has four columns for \fBmatch\fR, \fBmatchend\fR, \fBtarget\fR and \fBkeyword\fR positions, some of which may be \f(CW\*(C`\-1\*(C'\fR (undefined).
.Sp
This function is a wrapper around the \s-1CQP\s0 command \f(CW\*(C`dump \f(CI$named_query\f(CW \f(CI$from\f(CW \f(CI$to\f(CW;\*(C'\fR provided for symmetry with the \fBundump\fR command.
.IP "\fI\f(CI$cqp\fI\fR\->\fBundump\fR(\fI\f(CI$named_query\fI\fR, \fI\f(CI@table\fI\fR);" 4
.IX Item "$cqp->undump($named_query, @table);"
Upload a table of corpus positions to a named query result in \s-1CQP.\s0  \fI\f(CI@table\fI\fR must be an array of array references, with two, three or four columns (where the third and fourth column hold \fBtarget\fR and \fBkeyword\fR anchors, respectively).  All rows in \fI\f(CI@table\fI\fR must have the same number of columns.  Use \f(CW\*(C`\-1\*(C'\fR for undefined anchor values.
.Sp
This method is not just a trivial wrapper around \s-1CQP\s0's \fBundump\fR command.  It stores the data in an appropriate format in a temporary disk file, and determines the correct form of the \s-1CQP\s0 command based on the number of columns in the table.
.ie n .IP "\fI\f(CI$status\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBstatus\fR;  # ""ok"" or ""error""" 4
.el .IP "\fI\f(CI$status\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBstatus\fR;  # ``ok'' or ``error''" 4
.IX Item "$status = $cqp->status; # ok or error"
.PD 0
.IP "\fI\f(CI$ok\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBok\fR;" 4
.IX Item "$ok = $cqp->ok;"
.IP "\fI\f(CI@lines\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBerror_message\fR;" 4
.IX Item "@lines = $cqp->error_message;"
.IP "\fI\f(CI$cqp\fI\fR\->\fBerror\fR(\fI\f(CI@message\fI\fR);" 4
.IX Item "$cqp->error(@message);"
.PD
Error handling functions.  \fBstatus\fR returns the status of the last \s-1CQP\s0 command executed, which is either \f(CW\*(Aqok\*(Aq\fR or \f(CW\*(Aqerror\*(Aq\fR.  \fBok\fR returns \fBtrue\fR or \fBfalse\fR, depending on whether the last command was completed successfully (i.e., it is a simple convenience wrapper for the expression \f(CW\*(C`($cqp\-\*(C'\fRstatus eq 'ok')>).  \fBerror_message\fR returns the error message (if any) generated by the last \s-1CQP\s0 command, as a list of \fBchomp\fRed lines.
.Sp
\&\fBerror\fR is an internal function used to report \s-1CQP\s0 errors.  It may also be of interest to application programs if a suitable error handler has been defined (see below).
.IP "\fI\f(CI$cqp\fI\fR\->\fBset_error_handler\fR(\fI&my_error_handler\fR);" 4
.IX Item "$cqp->set_error_handler(&my_error_handler);"
.PD 0
.IP "\fI\f(CI$cqp\fI\fR\->\fBset_error_handler\fR('die' | 'warn' | 'ignore');" 4
.IX Item "$cqp->set_error_handler('die' | 'warn' | 'ignore');"
.PD
The first form of the \fBset_error_handler\fR method activates a user-defined error handler.  The argument is a reference to a named or anonymous subroutine, which will be called whenever a \s-1CQP\s0 error is detected (or an error is raised explicitly with the \fBerror\fR method).  The error message is passed to the handler as an array of \fBchomp\fRed lines.  If the error handler returns, the error condition will subsequently be ignored (but still be reported by \fBstatus\fR and \fBok\fR).
.Sp
The second form of the method activates one of the built-in error handlers:
.RS 4
.IP "\(bu" 4
\&\fB\f(CB\*(Aqdie\*(Aq\fB\fR aborts program execution with an error message; this handler is particularly convenient for one-off scripts or command-line utilities that do not need to recover from error conditions.
.IP "\(bu" 4
\&\fB\f(CB\*(Aqwarn\*(Aq\fB\fR prints the error message on \s-1STDERR,\s0 but continues program execution.  This is the default error handler of a new \fB\s-1CWB::CQP\s0\fR object.
.IP "\(bu" 4
\&\fB\f(CB\*(Aqignore\*(Aq\fB\fR silently ignores all errors.  The application script should check for error conditions after every \s-1CQP\s0 command, using the \fBok\fR or \fBstatus\fR method.
.RE
.RS 4
.RE
.IP "\fI\f(CI$query\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBquote\fR(\fI\f(CI$regexp\fI\fR);" 4
.IX Item "$query = $cqp->quote($regexp);"
.PD 0
.IP "\fI\f(CI$regexp\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBquotemeta\fR(\fI\f(CI$string\fI\fR);" 4
.IX Item "$regexp = $cqp->quotemeta($string);"
.PD
Safely quotes regular expressions and literal strings for use in \s-1CQP\s0 queries and other commands.
The \fBquote\fR method encloses \fI\f(CI$regexp\fI\fR in single or double quotes, as appropriate, and escapes quote characters inside the string by doubling.
\&\fBquotemeta\fR escapes all known regular expression metacharacters in \fI\f(CI$string\fI\fR with backslashes (including the backslash itself).
It does not surround \fI\f(CI$string\fI\fR with quotes, so if you want a \s-1CQP\s0 expression that searches \fI\f(CI$string\fI\fR as a literal string, you have to combine them into \f(CW\*(C`$cqp\->quote($cqp\->quotemeta($string))\*(C'\fR.  Both methods are vectorised, so you can pass multiple arguments in one call.
.IP "\fI\f(CI$cqp\fI\fR\->\fBdebug\fR(1);" 4
.IX Item "$cqp->debug(1);"
.PD 0
.IP "\fI\f(CI$cqp\fI\fR\->\fBdebug\fR(0);" 4
.IX Item "$cqp->debug(0);"
.PD
Activate/deactivate debugging mode, which logs all executed commands and their complete output on \s-1STDOUT.\s0  The \fBdebug\fR method returns the previous status for convenience.
.IP "\fI\f(CI$cqp\fI\fR\->\fBprogress_on\fR;" 4
.IX Item "$cqp->progress_on;"
.PD 0
.IP "\fI\f(CI$cqp\fI\fR\->\fBprogress_off\fR;" 4
.IX Item "$cqp->progress_off;"
.IP "\fI\f(CI$message\fI\fR = \fI\f(CI$cqp\fI\fR\->\fBprogress\fR;" 4
.IX Item "$message = $cqp->progress;"
.IP "(\fI\f(CI$total\fI\fR, \fI\f(CI$pass\fI\fR, \fI\f(CI$n_passes\fI\fR, \fI\f(CI$msg\fI\fR, \fI\f(CI$percent\fI\fR) = \fI\f(CI$cqp\fI\fR\->\fBprogress_info\fR;" 4
.IX Item "($total, $pass, $n_passes, $msg, $percent) = $cqp->progress_info;"
.PD
\&\s-1CQP\s0 progress messages can be activated and deactivated with the \fBprogress_on\fR and \fBprogress_off\fR methods (corresponding to \f(CW\*(C`set ProgressBar on|off;\*(C'\fR in \s-1CQP\s0).
.Sp
If active, progress information can be obtained with the method \fBprogress\fR, which returns the last progress message received from \s-1CQP.\s0  The \fBprogress_info\fR returns pre-parsed progress information, consisting of estimated total percentage of completion (\fI\f(CI$total\fI\fR), the current pass (\fI\f(CI$pass\fI\fR) and total number of passes (\fI\f(CI$n_passes\fI\fR) for multi-pass operations, the information part (\fI\f(CI$msg\fI\fR, either a percentage or a free-form progress message), and the completion percentage of the current pass (\fI\f(CI$percent\fI\fR).
.Sp
It is an error to call \fBprogress\fR or \fBprogress_info\fR without activating progress messages first.
.IP "\fI\f(CI$cqp\fI\fR\->\fBset_progress_handler\fR(\fI&my_progress_handler\fR);" 4
.IX Item "$cqp->set_progress_handler(&my_progress_handler);"
Set a user-defined progress handler, which will be invoked whenever new progress information is received from \s-1CQP.\s0  The argument must be a named or anonymous subroutine, which will be called with the information returned by \fBprogress_info\fR.  Note that setting a user-defined progress handler does \fInot\fR automatically activate progress information: you still need to call \fBprogress_on\fR for this purpose.
.Sp
Calling \fBset_progress_handler\fR with \fBundef\fR (or without an argument) disables the user-defined progress handler.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2002\-2022 Stephanie Evert [https://purl.org/stephanie.evert]
.PP
This software is provided \s-1AS IS\s0 and the author makes no warranty as to
its use and performance. You may use the software, redistribute and
modify it under the same terms as Perl itself.
